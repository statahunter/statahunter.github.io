---
layout:     post   				    # 使用的布局（不需要改）
title:      正则表达式 				# 标题 
subtitle:           #副标题
date:       2019-10-11 				# 时间
author:     卡匹迪恩 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 正则表达式
---

## 正则表达式

### 为什么使用正则表达式

​	典型的搜索和替换操作要求提供与预期的搜索结果匹配的确切文本。虽然，这种技术对静态文本执行简单搜索和替换任务可能已经足够了，但缺乏灵活性的，若采用这种技术搜索动态文本，即使不是不可能，至少也会变得很困难。

​	通过使用正则表达式，可以：

+ 测试字符串内得模式。****

  例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡模式。这称为数据验证。

+ 替换文本

  可以使用正则表达式来识别文档中的特定文本，完全删除文本或者用其他文本来替换。

+ 基于模式匹配从字符串中提取字符串

  可以查找文档内或输入域内特定的文本。

### 正则表达式——语法
​	正则表达式（regular expression）描述一种字符串匹配的模式（pattern），可以用来检查一个字符串是否含有牟总字符串，将匹配的字符串替换或者从某个字符串中取出符合某个字符串的子字符串。例如：

+ runoo+b：可以匹配runoob、runooob、runoooob等，“+”号都代表前面的字符必须至少出现一次（1次或多次）。
+ runoo*b：可以匹配runob、runoob、runoooob等，“\*”号代表字符串可以不出现，也可以出现一次或者多次（0次、1次或多次）。
+ colou？r：可以匹配color或者colour，“？”代表前面的字符串最多只可以出现一次（0次或1次）。

构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与运算符可以将小的表达式结合在一起创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。

​	正则表达式是有普通字符（例如字符a到z）以及特殊字符（称为元字符）组成的文字描述。模式描述是在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与搜索的字符串进行匹配。

普通字符

    普通字符包含没有显示指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、非所有标点符号和一些其他符号。
非打印字符

    非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：

| 字符 | 描述                                                         |
| ---- | ------------------------------------------------------------ |
| \cx  | 匹配有x指明的控制字符例如:\cm匹配一个Control-M或回车符。x的值必须为A~Z或a~z之中的一个，否则将C视为一个原义的"c"字符。 |
| \f   | 匹配一个换页符。等价于\xOc和\cL                              |
| \n   | 匹配一个换行符。等价于\xOd和\cJ                              |
| \r   | 匹配一个回车符。等价于\xOd和\cM                              |
| \s   | 匹配任何空白字符，包括空格\制表符\换页符等等.等价于{\f\n\r\t\v}。注意Unicode正则表达式会匹配全角空格符。 |
| \S   | 匹配任何非空白字符。等价于{^\f\n\r\t\v}                      |
| \t   | 匹配一个制表符。等价于\xOq和\cI                              |
| \v   | 匹配一个垂直制表符。等价于\xOb和\cK                          |

特殊字符

    所谓特殊字符,就是一些含有特殊含义的字符,如上面说的runoo*b中的*,简单的说就是表示任何字符串的意思.如果要查找字符串中的*符号,则需要对*进行转义,即在其前加一个"\";runo\*ob匹配runo*ob。
    许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符“转义”,即，将反斜杠字符“\”放在它们前面。下表列出了正则表达式中的特殊字符：

| 特殊字符 | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| $        | 匹配已输入字符串的结尾位置。如果设置了RegExp对象的Multiline属性，则$也匹配“\n”或“\r”。要匹配$字符本身，请用\\$。 |
| ()       | 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符。请使用\\(和\\)。 |
| *        | 匹配前面的子表达式0次或多次。要匹配*字符，请使用\\\*。       |
| +        | 匹配前面的子表达式1次或多次。要匹配+字符，请使用\\+。        |
| .        | 匹配除换行符\\n之外的任何单字符，要匹配.字符，请使用\\.。    |
| [        | 标记一个中括号表达式的开始。要匹配[字符，请使用\\[。         |
| ?        | 匹配前面的子表达式0次或1次，或指明一个非贪婪限定符。要匹配？字符，请使用\\?。 |
| \        | 将一个字符标记为特殊字符、或原义字符、或向后引用字符、或八进制转义字符。例如‘n’匹配字符‘n’，‘\n’匹配换行符。序列‘\\\’匹配‘\’，而‘\\(’则匹配‘（’。 |
| ^        | 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配^字符，请使用\\^。 |
| {        | 标记限定符表达式的开始。要匹配{，请使用\\{。                 |
| \|       | 指明两项之间的一个选择。要匹配\|，请使用\\|。                |

限定符

| 字符  | 描述                                                         |
| ----- | ------------------------------------------------------------ |
| *     | 匹配前面的子表达式0次或多次。例如，‘ZO*’能匹配‘Z’以及‘ZOO’。\*等价于{0,}。 |
| +     | 匹配前面的子表达式1次或多次。例如，‘ZO+’能匹配‘ZO’以及‘ZOO’，但不能匹配‘Z’。\+等价于{1,}。 |
| ？    | 匹配前面的子表达式0次或1次。例如，‘do(es)?’可以匹配‘do’，‘does’中的‘does’，‘doxy’中的‘do’。\?等价于{0,1}。 |
| {n}   | n是一个非负整数。匹配确定的n次。例如，‘o{2}’不能匹配‘Bob’中的‘o’，但是能匹配‘food’中的两个‘o’。 |
| {n,}  | n是一个非负整数。至少匹配n次。例如，‘o{2,}’不能匹配‘Bob’中的‘o’，但能匹配‘fooood’中的多有‘o’。‘o{1,,}’等价于‘o+’，‘0{0,}’等价于‘0*’。 |
| {n,m} | m和n均为负整数，其中n<=m。最少匹配n次，最多匹配m次。例如，‘o{1,3}’将匹配‘foooooood’中的前三个o。‘o{0,1}’等价于‘o？’。请注意在逗号和两个数之间不能有空格。 |

    由于章节编号在大的输入文档中会很可能超过九，所以我们需要一种方式来处理两位或三位章节编号。限定符给我们这种能力。下面的正则表达式匹配编号为任何位数的章节标题：
    	/Chapter [1-9][0-9]*/
    请注意，限定符出现在范围表达式之后。因此，它应用于整个范围表达式，在本例中，只指定从0到9的数字（包括0和9）。这里不使用+限定符，因为在第二个位置或后面的位置不一定需要有一个数字。也不使用？字符，因为？字符会将章节编号限制到只有两位数。
    这里至少需要匹配Chapter和空格字符后面的1个数字。如果知道了章节编号被限制为只有99章，可以使用下面的表达式来至少指定一位但至多两位数字。
    	/Chapter [0-9]{1,2}/
    上面的表达式的缺点时，大于99的章节编号只匹配开头两位数字。另一个缺点是“Chapter 0”也将匹配。只匹配两位数字的更好表达式如下：
    	/Chapter [1-9][0-9]?/
    	或
    	/Chapter [1-9][0-9]{0,1}/
    *，+限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个？才可以实现非贪婪或最小匹配。
    例如，可能搜索HTML文档，以查找括在H1标记内的章节标题。该文本在文档中如下：
    	<H1>Chapter 1 - 介绍正则表达式</H1>
    贪婪：下面的表达式匹配从开始小于符号（<）到关闭大于符号（>）之间的所有内容。
    	/<.*>/
    非贪婪：如果只需要匹配开始和结束的H1标签，下面的非贪婪表达式只匹配<H1>。
    	/<.?>/
    如果只想匹配开始的H1标签，表达式则是：
    	/<\w+?>/
    通过在*、+或？限定符之后放置？该表达式从“贪心”表达式转化为“非贪心”表达式或最小匹配。

定位符

    定位符能够将正则表达式固定到行首或行尾，它们还能够创建特定的表达式，这些表达式出现在一个单词内、或一个单词的开头或一个单词的结尾。
    定位符用来描述字符串或单词的边界，^和$分别之字符串的开始与结束，\b描述单词的前或后边界，\B表示非单词边界。
    正则表达式边界定位符有：

| 字符 | 描述                                                         |
| ---- | ------------------------------------------------------------ |
| ^    | 匹配输入字符开始的位置，如果设置了RegExp对象的Multiline属性，^还会与\n或\r之后的位置匹配。 |
| $    | 匹配输入字符串结尾的位置。如果设置了RegExp对象的Multiline属性，$还会与\n或\r之前的位置匹配。 |
| \b   | 匹配一个单词边界。即字符与空格间的位置。                     |
| \B   | 非单词边界匹配                                               |

    注意：
        不能将限定符与定位符一起使用。由于在紧靠换行符或单词边界的前面或后面不能有一个以上的位置，因此不允许诸如^*之类的表达式。
        若要匹配一行文本开始的若干字符，在正则表达式的开始使用^字符。不要将^的用法与其在中括号表达式内的用法混淆。
        若要匹配一行文本结束的字符，在正则表达式结束出用$字符。
        若要在搜索章节标题时使用定位符，下面的正则表达式匹配一个章节标题，该标题只包含两个尾随数字，并且出现在行首：
            /^Chapter [1-9][0-9]{0,1}/
        真正的章节标题不仅出现在行的开始处，而且还是该行仅有的文本。它既出现在行首又出现在同一行的结尾。下面的表达式能确保指定的匹配只匹配章节标题而不匹配交叉引用。通过创建只匹配一行文本的开始和结尾的正则表达式，就可以做到这一点：
        /^Chapter [1-9][0-9]{0,1}$/
    匹配单词边界稍有不同，但向正则表达式添加了很重要的能力。单词边界是单词和空格之间的位置。下面的表达式匹配单词Chapter的开头三个字符，因为这三个字符出现在单词边界后面：
        /\b/Cha/
    \b字符的位置是非常重要的。如果它位于要匹配的字符串的开始，它在单词的开始查找匹配项。如果它位于字符串的结尾，它在单词的结尾处查匹配项。例如，下面的表达式匹配单词Chapter中的字符串ter，因为它出现在单词边界的前面：
        /ter\b/
    下面的表达式匹配Chapter中的字符串apt，但不匹配aptitude中的字符串apt：
        /\Bapt/
    字符串apt出现在单词Chapter中的非单词边界，但出现在单词aptitude中的单词边界处。对于\B非单词边界运算符，位置并不重要，因为匹配不关心究竟是单词的开头还是结尾。

选择

    用圆括号将所有选择项括起来，相邻的选择项之间用“|”分隔。但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可将?:放在第一个选项前来消除这种副作用。其中?:是非捕获元之一，还有两个非捕获元是?=和?!，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号的正则表达式模式的位置来匹配搜索字符串，后者为负向查询，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符。

反向引用

    对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照正则表达式模式中从左到右出现的顺序存储，缓存区编号从1开始，最多可存储9个捕获的子表达式。每个缓冲区都可以使用\n访问，其中n为一个标识特定缓冲区的一位或两位十进制。
    可以使用非捕获元字符?:、?=或?!来重写捕获，忽略对相关匹配的保存。
    反向引用的最简单的、最有用的应用之一是提供查找文本中两个相同的相邻单词的匹配项的能力。一下面的例子为例：
        Is is the cost of of gasoline going up up?
    上面的句子显然有多个重复的单词。如果能设计一种方法定位该句子，而不必查找每个重复出现的单词，那该有多好。下面的正则表达式使用单个子表达式来实现这一点：
    查找重复的单词
        var str = 'Is is the cost of of gasoline going up';
        var patt1 = /\b([a-z]+) \1\b/ig;
        document.write(str.match(patt1));
        >>>Is is,of of,up up
    捕获的表达式，正如[a-z]+指定的，包括一个或多个字母。正则表达式的第二部分是对以前捕获的子匹配项的引用，即单词的第二个匹配项正好由括号表达式匹配。\1指定第一个子匹配模式（([a-z]+)）。
    单词边界元字符确保只检测整个单词，否则，诸如“is issued”或“this is”之类的词组将不能正确地被此表达式识别。正则表达式后面的全局标记`g`指定将该表达式应用到输入字符串能够查到的尽可能多的匹配。
    表达式的结尾的不区分大小写`i`标记指定不区分大小写。
    多行标记指定换行符的两边可能出现潜在的匹配。
    反向引用还可以将通用资源指示符（URI）分解为其组件。假定想将下面的URI分解为协议（ftp、http等等）、域地址和页/路径：
    http://www.runoob.com:80/html/html-tutorial.html
    下面的正则表达式能够实现该功能：
        var str = "http://www.runoob.com:80/html/html-tutorial.html";
        var patt1 = /(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)/;
        arr = str.match(patt1);
        for (var i = 0; i < arr.length; i++){
            document.write(arr[i]);
            document.write("<br>");
        }
    第一个括号子表达式捕获Web地址的写一部分。该子表达式匹配在冒号和两个斜杠前面的任何单词。
    第二个括号子表达式捕获地址的域地址部分。子表达式匹配`:`和`/`之后的一个或多个字符。
    第三个括号子表达式捕获端口号（如果指定了的话）。该子表达式匹配冒号后面的0个或多个数字。只能重复一次该子表达式。
    第四个括号子表达式捕获Web地址指定的路径和/或页信息。该子表达式能匹配不包括#或空格字符的任何字符序列。
    将正则表达式应用到上面的URI，各子匹配项包含下面的内容：
        第一个括号子表达式http
        第二个括号子表达式包含www.runoob.com
        第三个括号子表达式包含：80
        第四个括号子表达式包含/html/html-tutorial.html

### 正则表达式——元字符（前面有的，相同的就不再写了）

下面是介绍元字符的完整列表以及它们在正则表达式上下文中的行为：

<table>
    <thead>
        <tr>
            <th style="width: 100px;">元字符</th>
            <th>描述</th>
        </tr>
     <thead>
        <tr>
            <th style="width: 100px;">\ </th>
            <th>将下一个字符标记为特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”，“\n”匹配一个换行字符，序列“\\”匹配“\”，而“\c”则匹配“c” </th>
        </tr>
    <thead>
        <tr>
            <th style="width: 100px;">? </th>
            <th>当该字符紧跟在任何一个其他限定符（*，+，？，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+？”将匹配单个“o”，而“o+”将匹配多有“o”。</th>
        </tr>
    <thead>
        <tr>
            <th style="width: 100px;">. </th>
            <th>匹配除换行符（\n，\r）之外的任何单个字符。要匹配包括“\n”在内的任何字符，请使用“（.\|\n）”的模式。</th>
        </tr>
    <thead>
        <tr>
            <th style="width: 100px;">(pattern)</th>
            <th>要匹配pattern并获取这一匹配。一般要用到match函数。要匹配圆括号请使用“\\(”或“\\)”。</th>
        </tr>
    <thead>
        <tr>
            <th style="width: 100px;">(?:pattern)</th>
            <th>匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用“或”字符（\|）来组合一个模式的各个部分是很有用的。例如，“industr(?:y\|ies)”就是一个比“industry\|industries”更简略的表达式。</th>
        </tr>
    <thead>
        <tr>
            <th style="width: 100px;">(?=pattern)</th>
            <th>正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows (?=95|98|NT|2000)”能匹配“Windows 2000”中的“Windows”，但不能匹配“Windows 3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生之后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符开始。</th>
        </tr>
    <thead>
        <tr>
            <th style="width: 100px;">(?!pattern)</th>
            <th>正向否定预查（negative assert），在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows (?!95|98|NT|2000)”能匹配“Windows 3.1”中的“Windows”，但不能匹配“Windows 2000”中的“Windows”。同样，预查不消耗字符。</th>
        </tr>
    <thead>
        <tr>
            <th style="width: 100px;">(?<=pattern)</th>
            <th>反向（look behind）肯定预查，与正向肯定类似，只是方向相反。例如，“(?<=95|98|NT|2000)Windows”能匹配“2000 Windows”中的“Windows”，但不能匹配“3.1 Windows”中的“Windows”。</th>
        </tr>
    <thead>
        <tr>
            <th style="width: 100px;">(?<!pattern)</th>
            <th>反向否定预查，与正向否定预查类似</th>
        </tr>
    <thead>
        <tr>
            <th style="width: 100px;">x|y</th>
            <th>匹配x或y。例如，“z|food”能匹配“z”或“food”。“(z|f)ood”则匹配“zood”或“food”。</th>
        </tr>
    <thead>
        <tr>
            <th style="width: 100px;">[abc]</th>
            <th>字符串集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“pain”中的“a”。</th>
        </tr>
    <thead>
        <tr>
            <th style="width: 100px;">[^abc]</th>
            <th>否定字符串集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“p”，“l”，“i”，“n”。</th>
        </tr>
    <thead>
        <tr>
            <th style="width: 100px;">[a-z]</th>
            <th>字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意字母字符。</th>
        </tr>
    <thead>
        <tr>
            <th style="width: 100px;">[^a-z]</th>
            <th>否定字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。</th>
        </tr>
    <thead>
        <tr>
            <th style="width: 100px;">\cx</th>
            <th>匹配由x指定的控制字符。例如，\cM匹配一个“Control-M”或回车符。x的值必须为“A-Z”和“a-z”之一。否则，将视\c为一个原义的“c”字符。</th>
        </tr>
    <thead>
        <tr>
            <th style="width: 100px;">\d</th>
            <th>匹配一个数字字符。等价于“[0-9]”。</th>
        </tr>
    <thead>
        <tr>
            <th style="width: 100px;">\f</th>
            <th>匹配一个换页符，等价于\x0c和\cL。</th>
        </tr>
    <thead>
        <tr>
            <th style="width: 100px;">\n</th>
            <th>匹配一个换行符，等价于\x0a和\cJ。</th>
        </tr>
    <thead>
        <tr>
            <th style="width: 100px;">\r</th>
            <th>匹配一个回车符，等价于\x0d和\cM。</th>
        </tr>
    <thead>
        <tr>
            <th style="width: 100px;">\w</th>
            <th>匹配字母、数字、下划线，等价于“[A-Za-z0-9_]”。</th>
        </tr>
    <thead>
        <tr>
            <th style="width: 100px;">\W</th>
            <th>匹配非字母、数字、下划线，等价于“[^A-Za-z0-9_]”。</th>
        </tr>
    <thead>
        <tr>
            <th style="width: 100px;">\xn</th>
            <th>匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的长度为2的两个数字。例如，“\x41”匹配“A”。正则表达式可以用ASCII编码。注：这里以十六进制的ASCII编码来匹配字符，并不是匹配十进制数字</th>
        </tr>
    <thead>
        <tr>
            <th style="width: 100px;">\num</th>
            <th>匹配num，其中num是一个正整数。对所获取的匹配模式的引用，例如“()\1”匹配两个连续的相同字符。</th>
        </tr>
    <thead>
        <tr>
            <th style="width: 100px;">\n</th>
            <th>标识一个八进制转义字符或一个向后引用。如果“\n”之前有至少n个获取的子表达式，则“\n”为向后引用，否则如果n为八进制数字（0-7），则“\n”为一个八进制转义值。</th>
        </tr>
    <thead>
        <tr>
            <th style="width: 100px;">\nm</th>
            <th>标识一个八进制转义值或一个向后引用。如果“\nm”之前至少有 nm 个获得子表达式，则“\nm”为向后引用。如果“\nm”之前至少有 n 个获取，则“\nm”为一个后面紧跟文字“m”的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则“\nm”将匹配八进制转义值nm。</th>
        </tr>
    <thead>
        <tr>
            <th style="width: 100px;">\nml</th>
            <th>如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。</th>
        </tr>
    <thead>
        <tr>
            <th style="width: 100px;">\un</th>
            <th>匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如，“ \u00A9” 匹配版权符号 (?)。</th>
        </tr>
</table>

### 正则表达式——运算符优先级

​	正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。

​	相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序：

<table>
    <thead>
        <tr>
            <th style="width: 100px;">运算符</th>
            <th>描述</th>
        </tr>
     <thead>
        <tr>
            <th style="width: 100px;">\ </th>
            <th> 转义符</th>
        </tr>
    <thead>
        <tr>
            <th style="width: 100px;">(),(?:),(?+),[] </th>
            <th>圆括号与方括号 </th>
        </tr>
    <thead>
        <tr>
            <th style="width: 100px;"> *,+,?,{n},{n,},{n,m}</th>
            <th> 限定符</th>
        </tr>
    <thead>
        <tr>
            <th style="width: 100px;"> ^,$,\任何元字符,\任何字符</th>
            <th> 定位点和序列（即：位置和顺序）</th>
        </tr>
    <thead>
        <tr>
            <th style="width: 100px;">| </th>
            <th>替换，"或"操作
字符具有高于替换运算符的优先级，使得"m|food"匹配"m"或"food"。若要匹配"mood"或"food"，请使用括号创建子表达式，从而产生"(m|f)ood"。 </th>
        </tr>
</table>

### 正则表达式——匹配规则

​	基本模式匹配

    一切从最基本的开始。模式，是正则表达式最基本的元素，它们是一组描述字符串特征的字符。模式可以很简单，由普通的字符串组成，也可以非常复杂，往往用特殊的字符表示一个范围内的字符、重复出现，或表示上下文。例如：
        ^once
    这个模式包含一个特殊的字符^，表示该模式只匹配那些以once开头的字符串。例如该模式与字符串"once upon a time"匹配，与"There once was a man from NewYork"不匹配。正如如^符号表示开头一样，$符号用来匹配那些以给定模式结尾的字符串。
        bucket$
    这个模式与"Who kept all of this cash in a bucket"匹配，与"buckets"不匹配。字符 ^ 和 $ 同时使用时，表示精确匹配（字符串与模式一样）。例如：
        ^bucket$
    只匹配字符串"bucket"。如果一个模式不包括^和$，那么它与任何包含该模式的字符串匹配。例如：模式
        once
    与字符串
        There once was a man from NewYork
        Who kept all of his cash in a bucket.
    是匹配的。
    在该模式中的字母(o-n-c-e)是字面的字符，也就是说，他们表示该字母本身，数字也是一样的。其他一些稍微复杂的字符，如标点符号和白字符（空格、制表符等），要用到转义序列。所有的转义序列都用反斜杠(\)打头。制表符的转义序列是 \t。所以如果我们要检测一个字符串是否以制表符开头，可以用这个模式：
        ^\t
    类似的，用\n表示"换行"，\r表示回车。其他的特殊符号，可以用在前面加上反斜杠，如反斜杠本身用\\表示，句号.用\.表示，以此类推。

字符簇

    在互联网的程序中，正则表达式通常用来验证用户的输入。当用户提交一个信息以后，要判断输入的电话号码、地址、EMAIL地址、信用卡号码等是否有效，用普通的基于字面的字符是不够的。
    所以要用一种更灵活的描述模式的办法，它就是字符簇。要建立一个表示所有元音字符的字符簇，就把所有的元音字符放在一个方括号里：
        [AaEeIiOoUu]
    这个模式与任何元音字符匹配，但只能表示一个字符。用连字号可以表示一个字符的范围，如：
        [a-z] ：匹配所有的小写字母 
        [A-Z] ：匹配所有的大写字母 
        [a-zA-Z]：/匹配所有的字母 
        [0-9] ：匹配所有的数字 
        [0-9\.\-]：匹配所有的数字，句号和减号 
        [ \f\r\t\n] ：匹配所有的白字符
    同样的，这些也只表示一个字符，这是一个非常重要的。如果要匹配一个由一个小写字母和一位数字组成的字符串，比如"z2"、"t6"或"g7"，但不是"ab2"、"r2d3" 或"b52"的话，用这个模式：
        ^[a-z][0-9]$
    尽管[a-z]代表26个字母的范围，但在这里它只能与第一个字符是小写字母的字符串匹配。
    前面曾经提到^表示字符串的开头，但它还有另外一个含义。当在一组方括号里使用 ^ 时，它表示"非"或"排除"的意思，常常用来剔除某个字符。还用前面的例子，我们要求第一个字符不能是数字：
        ^[^0-9][0-9]$
    这个模式与"&5"、"g7"及"-2"是匹配的，但与"12"、"66"是不匹配的。下面是几个排除特定字符的例子：
        [^a-z] //除了小写字母以外的所有字符 
        [^\\\/\^] //除了(\)(/)(^)之外的所有字符 
        [^\"\'] //除了双引号(")和单引号(')之外的所有字符
    特殊字符 .(点，句号)在正则表达式中用来表示除了"新行"之外的所有字符。所以模式 ^.5$ 与任何两个字符的、以数字5结尾和以其他非"新行"字符开头的字符串匹配。模式 . 可以匹配任何字符串，除了空串和只包括一个"新行"的字符串。
    PHP的正则表达式有一些内置的通用字符簇，列表如下：
<table>
    <thead>
        <tr>
            <th style="width: 100px;">字符簇</th>
            <th>描述</th>
        </tr>
    <thead>
        <tr>
            <th style="width:100px;">[[:alpha:]]</th>
            <th>任何字母</th>
        </tr>
    <thead>
        <tr>
            <th style="width:100px;">[[:digit:]]</th>
            <th>任何数字</th>
        </tr>
    <thead>
        <tr>
            <th style="width:100px;">[[:alnum:]]</th>
            <th>任何字母与数字</th>
        </tr>
    <thead>
        <tr>
            <th style="width:100px;">[[:space:]]</th>
            <th>任何空白字符</th>
        </tr>
    <thead>
        <tr>
            <th style="width:100px;">[[:upper:]]</th>
            <th>任何大写字母</th>
        </tr>
    <thead>
        <tr>
            <th style="width:100px;">[[:lower:]]</th>
            <th>任何小写字母</th>
        </tr>
    <thead>
        <tr>
            <th style="width:100px;">[[:punct:]]</th>
            <th>任何标点符号</th>
        </tr>
    <thead>
        <tr>
            <th style="width:100px;">[[:xdigit:]]</th>
            <th>任何16进制的数字，相当于[0-9a-fA-F]。</th>
        </tr>
</table>


确定重复出现

    到现在为止，已经知道如何去匹配一个字母或数字，但更多的情况下，可能要匹配一个单词或一组数字。一个单词有若干个字母组成，一组数字有若干个单数组成。跟在字符或字符簇后面的花括号({})用来确定前面的内容的重复出现的次数。
<table>
    <thead>
        <tr>
            <th style="width:100px;">字符簇</th>
            <th>描述</th>
        </tr>
    <thead>
        <tr>
            <th style="width:100px;">^[a-zA-Z_]$</th>
            <th>所有的字母和下划线</th>
        </tr>
    <thead>
        <tr>
            <th style="width:100px;">^[[:alpha:]]{3}$</th>
            <th>所有的3个字母的单词</th>
        </tr>
    <thead>
        <tr>
            <th style="width:100px;">^a$</th>
            <th>字母a</th>
        </tr>
    <thead>
        <tr>
            <th style="width:100px;">^a{4}$</th>
            <th>aaaa</th>
        </tr>
    <thead>
        <tr>
            <th style="width:100px;">^a{2,4}$</th>
            <th>aa，aaaa或aaaa</th>
        </tr>
    <thead>
        <tr>
            <th style="width:100px;">^a{1,3}$</th>
            <th>a，aa或aaa</th>
        </tr>
    <thead>
        <tr>
            <th style="width:100px;">^a{2,}$</th>
            <th>包含多余两个a的字符串</th>
        </tr>
    <thead>
        <tr>
            <th style="width:100px;">^a{2,}</th>
            <th>如：aardvark和aaab，但apple不行</th>
        </tr>
    <thead>
        <tr>
            <th style="width:100px;">a{2,}</th>
            <th>如：baad和aaa，但Nantucket不行</th>
        </tr>
    <thead>
        <tr>
            <th style="width:100px;">\t{2}</th>
            <th>两个制表符</th>
        </tr>
    <thead>
        <tr>
            <th style="width:100px;">.{2}</th>
            <th>所有的两个字符</th>
        </tr>
</table>

    这些例子描述了花括号的三种不同的用法。一个数字 {x} 的意思是前面的字符或字符簇只出现x次 ；一个数字加逗号 {x,} 的意思是前面的内容出现x或更多的次数 ；两个数字用逗号分隔的数字 {x,y} 表示 前面的内容至少出现x次，但不超过y次。我们可以把模式扩展到更多的单词或数字：
        ^[a-zA-Z0-9_]{1,}$      // 所有包含一个以上的字母、数字或下划线的字符串 
        ^[1-9][0-9]{0,}$        // 所有的正整数 
        ^\-{0,1}[0-9]{1,}$      // 所有的整数 
        ^[-]?[0-9]+\.?[0-9]+$   // 所有的浮点数
    最后一个例子不太好理解，是吗？这么看吧：以一个可选的负号 ([-]?) 开头 (^)、跟着1个或更多的数字([0-9]+)、和一个小数点(\.)再跟上1个或多个数字([0-9]+)，并且后面没有其他任何东西($)。下面你将知道能够使用的更为简单的方法。
    特殊字符 ? 与 {0,1} 是相等的，它们都代表着： 0个或1个前面的内容 或 前面的内容是可选的 。所以刚才的例子可以简化为：
        ^\-?[0-9]{1,}\.?[0-9]{1,}$
    特殊字符 * 与 {0,} 是相等的，它们都代表着 0 个或多个前面的内容 。最后，字符 + 与 {1,} 是相等的，表示 1 个或多个前面的内容 ，所以上面的4个例子可以写成：
        ^[a-zA-Z0-9_]+$      // 所有包含一个以上的字母、数字或下划线的字符串 
        ^[1-9][0-9]*$        // 所有的正整数 
        ^\-?[0-9]+$          // 所有的整数 
        ^[-]?[0-9]+(\.[0-9]+)?$ // 所有的浮点数
    当然这并不能从技术上降低正则表达式的复杂性，但可以使它们更容易阅读。

### 正则表达式——示例

简单表达式

    正则表达式的最简单形式是在搜索字符串中匹配其本身的单个普通字符。例如，单字符模式，如 A，不论出现在搜索字符串中的何处，它总是匹配字母 A。下面是一些单字符正则表达式模式的示例：
        /a/
        /7/
        /M/
    可以将许多单字符组合起来以形成大的表达式。例如，以下正则表达式组合了单字符表达式：a、7 和 M。
        /a7M/
    请注意，没有串联运算符。只须在一个字符后面键入另一个字符。

字符匹配

    句点 (.) 匹配字符串中的各种打印或非打印字符，只有一个字符例外。这个例外就是换行符 (\n)。下面的正则表达式匹配 aac、abc、acc、adc 等等，以及 a1c、a2c、a-c 和 a#c：
        /a.c/
    若要匹配包含文件名的字符串，而句点 (.) 是输入字符串的组成部分，请在正则表达式中的句点前面加反斜杠 (\) 字符。举例来说明，下面的正则表达式匹配 filename.ext：
        /filename\.ext/
    这些表达式只让您匹配"任何"单个字符。可能需要匹配列表中的特定字符组。例如，可能需要查找用数字表示的章节标题（Chapter 1、Chapter 2 等等）。

中括号表达式

    若要创建匹配字符组的一个列表，请在方括号（[ 和 ]）内放置一个或更多单个字符。当字符括在中括号内时，该列表称为"中括号表达式"。与在任何别的位置一样，普通字符在中括号内表示其本身，即，它在输入文本中匹配一次其本身。大多数特殊字符在中括号表达式内出现时失去它们的意义。不过也有一些例外，如：
        如果 ] 字符不是第一项，它结束一个列表。若要匹配列表中的 ] 字符，请将它放在第一位，紧跟在开始 [ 后面。
        \ 字符继续作为转义符。若要匹配 \ 字符，请使用 \\。
    括在中括号表达式中的字符只匹配处于正则表达式中该位置的单个字符。以下正则表达式匹配 Chapter 1、Chapter 2、Chapter 3、Chapter 4 和 Chapter 5：
        /Chapter [12345]/
    请注意，单词 Chapter 和后面的空格的位置相对于中括号内的字符是固定的。中括号表达式指定的只是匹配紧跟在单词 Chapter 和空格后面的单个字符位置的字符集。这是第九个字符位置。
    若要使用范围代替字符本身来表示匹配字符组，请使用连字符 (-) 将范围中的开始字符和结束字符分开。单个字符的字符值确定范围内的相对顺序。下面的正则表达式包含范围表达式，该范围表达式等效于上面显示的中括号中的列表。
        /Chapter [1-5]/
    当以这种方式指定范围时，开始值和结束值两者都包括在范围内。注意，还有一点很重要，按 Unicode 排序顺序，开始值必须在结束值的前面。
    若要在中括号表达式中包括连字符，请采用下列方法之一：
        用反斜杠将它转义：
            [\-]
        将连字符放在中括号列表的开始或结尾。下面的表达式匹配所有小写字母和连字符：
            [-a-z]
            [a-z-]
        创建一个范围，在该范围中，开始字符值小于连字符，而结束字符值等于或大于连字符。下面的两个正则表达式都满足这一要求：
            [!--]
            [!-~]
    若要查找不在列表或范围内的所有字符，请将插入符号 (^) 放在列表的开头。如果插入字符出现在列表中的其他任何位置，则它匹配其本身。下面的正则表达式匹配1、2、3、4 或 5 之外的任何数字和字符：
        /Chapter [^123456]/
    在上面的示例中，表达式在第九个位置匹配 1、2、3、4 或 5 之外的任何数字和字符。这样，例如，Chapter 7 就是一个匹配项，Chapter 9 也是一个匹配项。
    上面的表达式可以使用连字符 (-) 来表示：
        /Chapter [^1-5]/
    中括号表达式的典型用途是指定任何大写或小写字母或任何数字的匹配。下面的表达式指定这样的匹配：
        /[A-Za-z0-9]/

替换和分组

    替换使用 | 字符来允许在两个或多个替换选项之间进行选择。例如，可以扩展章节标题正则表达式，以返回比章标题范围更广的匹配项。但是，这并不象您可能认为的那样简单。替换匹配 | 字符任一侧最大的表达式。
    您可能认为，下面的表达式匹配出现在行首和行尾、后面跟一个或两个数字的 Chapter 或 Section：
        /^Chapter|Section [1-9][0-9]{0,1}/
    很遗憾，上面的正则表达式要么匹配行首的单词 Chapter，要么匹配行尾的单词 Section 及跟在其后的任何数字。如果输入字符串是 Chapter 22，那么上面的表达式只匹配单词 Chapter 22。如果输入字符串是 Section 22，那么该表达式匹配 Section 22。
    若要使正则表达式更易于控制，可以使用括号来限制替换的范围，即，确保它只应用于两个单词 Chapter 和 Section。但是，括号也用于创建子表达式，并可能捕获它们以供以后使用，这一点在有关反向引用的那一节讲述。通过在上面的正则表达式的适当位置添加括号，就可以使该正则表达式匹配 Chapter 1 或 Section 3。
    下面的正则表达式使用括号来组合 Chapter 和 Section，以便表达式正确地起作用：
        /^(Chapter|Section) [1-9][0-9]{0,1}/
    尽管这些表达式正常工作，但 Chapter|Section 周围的括号还将捕获两个匹配字中的任一个供以后使用。由于在上面的表达式中只有一组括号，因此，只有一个被捕获的"子匹配项"。
    在上面的示例中，您只需要使用括号来组合单词 Chapter 和 Section 之间的选择。若要防止匹配被保存以备将来使用，请在括号内正则表达式模式之前放置 ?:。下面的修改提供相同的能力而不保存子匹配项：
        /^(?:Chapter|Section) [1-9][0-9]{0,1}$/
    除 ?: 元字符外，两个其他非捕获元字符创建被称为"预测查询"匹配的某些内容。正向预测查询使用 ?= 指定，它匹配处于括号中与正则表达式模式匹配的起始点的搜索字符串。反向预测查询使用 ?! 指定，它匹配处于与正则表达式模式不匹配的字符串的起始点的搜索字符串。
    例如，假设您有一个文档，该文档包含指向 Windows 3.1、Windows 95、Windows 98 和 Windows NT 的引用。再进一步假设，您需要更新该文档，将指向 Windows 95、Windows 98 和 Windows NT 的所有引用更改为 Windows 2000。下面的正则表达式（这是一个正向预测查询的示例）匹配 Windows 95、Windows 98 和 Windows NT：
        /Windows(?=95 |98 |NT )/
    找到一处匹配后，紧接着就在匹配的文本（不包括预测先行中的字符）之后搜索下一处匹配。例如，如果上面的表达式匹配 Windows 98，将在 Windows 之后而不是在 98 之后继续搜索。